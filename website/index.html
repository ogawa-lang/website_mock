// content.js - WebページのDOMを操作して文言をチェック・ハイライトする
// v2.8 - 例外リスト(exception_words)のロジックを強化

(async () => {
  // 1. 単一の "rules.json" を読み込む
  const rules = await loadRules();
  if (!rules) {
    console.error('Web文言チェッカー: ルールの読み込みに失敗しました。');
    return;
  }

  // 2. 初回スキャンを実行
  await scanAndHighlight(document.body, rules);

  // 3. (おまけ) ページが動的に変更された場合も監視する
  const observer = new MutationObserver((mutations) => {
    let needsScan = false;
    mutations.forEach((mutation) => {
      mutation.addedNodes.forEach((node) => {
        // サイドバー自体の変更は無視する (v3.0の名残だが、安全のためキープ)
        if (node.nodeType === 1 && node.id === 'web-checker-sidebar') {
          return;
        }
        if (node.nodeType === 1 || node.nodeType === 3) {
          needsScan = true;
        }
      });
    });

    if(needsScan) {
      scanAndHighlight(document.body, rules);
    }
  });

  observer.observe(document.body, {
    childList: true,
    subtree: true
  });

})();

/**
 * 拡張機能内の "rules.json" を非同期で読み込む
 */
async function loadRules() {
  try {
    const url = chrome.runtime.getURL('rules.json'); // 読み込むファイルを 'rules.json' に固定
    const response = await fetch(url);
    if (!response.ok) {
      console.error('Web文言チェッカー: rules.json の読み込みに失敗しました。');
      return null;
    }
    return await response.json();
  } catch (e) {
    console.error('Web文言チェッカー: ルール読み込みエラー:', e);
    return null;
  }
}

/**
 * 指定された要素（またはノード）以下をスキャンしてハイライトする
 * @param {Node} rootNode - スキャンを開始するDOMノード
 * @param {object} rules - ガイドラインルール
 */
async function scanAndHighlight(rootNode, rules) {

  // 正規表現で使用するルールを結合 (v2.6ロジック)
  const combinedRegex = buildRegex(rules);
  if (!combinedRegex) return; 
  
  // v2.7: 例外リストの正規表現を作成
  const exceptionRegex = buildExceptionRegex(rules.exception_words);

  // --- 1. テキストノードのスキャン (TreeWalker) ---
  if (rootNode.nodeType === 3 || rootNode.nodeType === 1) {
    const walker = document.createTreeWalker(
      rootNode,
      NodeFilter.SHOW_TEXT,
      null,
      false
    );

    let node;
    const nodesToProcess = [];
    while ((node = walker.nextNode())) {
      nodesToProcess.push(node);
    }

    for (const node of nodesToProcess) {
      const parentTag = node.parentElement ? node.parentElement.tagName.toLowerCase() : '';
      if (parentTag === 'script' || parentTag === 'style' ||
          (node.parentElement && node.parentElement.classList.contains('web-checker-highlight-forbidden')) ||
          (node.parentElement && node.parentElement.classList.contains('web-checker-highlight-preferred'))
      ) {
        continue;
      }

      const text = node.nodeValue;
      
      // v2.8: v2.7の不完全な例外チェック (exceptionRegex.test(text)) は削除

      if (!text || text.trim() === '' || !combinedRegex.test(text)) {
        continue;
      }

      const parent = node.parentNode;
      if (!parent) continue;

      const fragment = document.createDocumentFragment();
      let lastIndex = 0;
      
      // replaceメソッドを使って、マッチしたすべての箇所を処理
      // v2.6の正規表現 `((?<!...)|(?<=...))(RuleWord)(?!...)` に基づき引数を整理
      text.replace(combinedRegex, (match, g1, g2, offset) => {
        // match = "素"
        // g1 = 境界 (undefined or 助詞)
        // g2 = "素" (ルールにマッチした単語本体)
        // offset = マッチ位置
        
        // v2.8: 例外チェックロジック
        if (exceptionRegex) {
            // マッチした単語(g2)が、例外単語("味の素"など)の一部でないかチェック
            const re = new RegExp(exceptionRegex); // gフラグ付き
            let m;
            let isException = false;
            while ((m = re.exec(text)) !== null) {
                // 例外（例: "味の素"）が見つかった
                const exceptionStart = m.index;
                const exceptionEnd = m.index + m[0].length;
                
                // ルール単語（例: "素"）の開始・終了位置
                const ruleStart = offset;
                const ruleEnd = offset + g2.length;
                
                // ルール単語（"素"）が、例外単語（"味の素"）に「包含」されているか
                if (ruleStart >= exceptionStart && ruleEnd <= exceptionEnd) {
                    isException = true;
                    break;
                }
            }
            
            if (isException) {
                // 例外（"味の素"）の一部だったので、ハイライトしない
                if (offset > lastIndex) {
                    fragment.appendChild(document.createTextNode(text.substring(lastIndex, offset)));
                }
                fragment.appendChild(document.createTextNode(g2)); // ハイライトせずテキストノードを戻す
                lastIndex = offset + g2.length;
                return; // replaceのコールバックを終了
            }
        }
        
        // 1. マッチした箇所の直前までのテキストノードを追加
        if (offset > lastIndex) {
          fragment.appendChild(document.createTextNode(text.substring(lastIndex, offset)));
        }
        
        // 2. マッチした単語(g2)をハイライトするSPANを作成
        const span = createHighlightSpan(g2, rules); // v2.8: exceptionRegex引数を削除
        
        fragment.appendChild(span);
        
        lastIndex = offset + g2.length;
      });

      // 3. 最後に残ったテキストノードを追加
      if (lastIndex < text.length) {
        fragment.appendChild(document.createTextNode(text.substring(lastIndex)));
      }
      parent.replaceChild(fragment, node);
    }
  }

  // --- 2. 画像(alt属性)のスキャン (querySelectorAll) ---
  if (rootNode.nodeType === 1) { 
    let images = [];
    if (rootNode.tagName && rootNode.tagName.toLowerCase() === 'img') {
      images.push(rootNode);
    }
    try {
        images.push(...rootNode.querySelectorAll('img:not([class*="web-checker-highlight-image"])'));
    } catch (e) {
        // console.warn("Web文言チェッカー: querySelectorAllに失敗", e);
    }

    for (const img of images) {
      const altText = img.alt;
      if (!altText || altText.trim() === '' || !combinedRegex.test(altText)) {
        continue;
      }
      
      // v2.7: altTextが例外リストにマッチする場合はスキップ
      if (exceptionRegex && exceptionRegex.test(altText)) {
        continue;
      }

      // alt属性のテキストをチェック (v2.6ロジック)
      const forbiddenRule = rules.forbidden_words.find(rule => rule.word && altText.includes(rule.word));
      if (forbiddenRule) {
          className = 'web-checker-highlight-image-forbidden';
          title = `alt属性に禁止語: '${forbiddenRule.word}'`;
          if (forbiddenRule.note) {
            title += ` (${forbiddenRule.note})`;
          }
          foundForbidden = true;
      }

      // 推奨語チェック (厳格)
      if (!foundForbidden) {
          const preferredRule = rules.preferred_terms.find(term => term.old && altText.includes(term.old));
          if (preferredRule) {
              className = 'web-checker-highlight-image-preferred';
              title = `alt属性に推奨語: '${preferredRule.old}' (→'${preferredRule.new}')`;
              if (preferredRule.note) {
                title += ` (${preferredRule.note})`;
              }
          }
      }

      img.classList.add(className);
      img.title = title;
    }
  }
}

/**
 * ルールからハイライト用の正規表現（RegExp）を構築する (v2.5ロジック)
 * (単語境界(日本語助詞対応) + 大文字小文字区別)
 */
function buildRegex(rules) {
  const allWords = [];
  if (rules.forbidden_words && Array.isArray(rules.forbidden_words)) {
    allWords.push(...rules.forbidden_words.filter(rule => rule && typeof rule.word === 'string').map(rule => escapeRegExp(rule.word)));
  }
  if (rules.preferred_terms && Array.isArray(rules.preferred_terms)) {
    allWords.push(...rules.preferred_terms.filter(term => term && typeof term.old === 'string').map(term => escapeRegExp(term.old)));
  }

  if (allWords.length === 0) return null;

  try {
    const validWords = allWords.filter(w => w.length > 0);
    if (validWords.length === 0) return null;
    // v2.6: 単語境界をチェックする正規表現を構築
    // (A|B|C) を ((?<![\p{L}\p{N}_])|(?<=[のがをはてに。、]))(A|B|C)(?![\p{L}\p{N}_]) に変更
    // 直前が「文字でない」OR「助詞・句読点である」場合にマッチ
    const pattern = `((?<![\\p{L}\\p{N}_])|(?<=[のがをはてに。、]))(${validWords.join('|')})(?![\\p{L}\\p{N}_])`;
    
    // 'g' (グローバル) と 'u' (ユニコード) フラグを使用
    // 'i' (大文字小文字無視) は削除 (v2.5)
    return new RegExp(pattern, 'gu'); 
  } catch (e) {
    console.error("Web文言チェッカー: 正規表現の構築に失敗しました。", e);
    // 'u'フラグ非対応環境用のフォールバック (簡易的)
    try {
      // \p{L} などのUnicodeプロパティの代わりに、日本語の範囲を明示
      // v2.6: 助詞対応
      const pattern = `((?<![a-zA-Z0-9_ぁ-んァ-ヶ一-龠])|(?<=[のがをはてに。、]))(${validWords.join('|')})(?![a-zA-Z0-9_ぁ-んァ-ヶ一-龠])`;
      return new RegExp(pattern, 'g');
    } catch (e2) {
      console.error("Web文言チェッカー: フォールバック正規表現も失敗。", e2);
      return null;
    }
  }
}

/**
 * v2.7: 例外ワードリストから正規表現を構築する
 */
function buildExceptionRegex(exceptionWords) {
  if (!exceptionWords || !Array.isArray(exceptionWords) || exceptionWords.length === 0) {
    return null;
  }
  try {
    const validWords = exceptionWords
      .filter(w => typeof w === 'string' && w.length > 0)
      .map(escapeRegExp);
      
    if (validWords.length === 0) return null;
    
    // 例外リストは単純な「含む」チェックでよいため、単語境界は設定しない
    const pattern = `(${validWords.join('|')})`;
    // 大文字小文字も区別する（v2.5ロジックに合わせる）
    return new RegExp(pattern, 'gu'); 
  } catch (e) {
    console.error("Web文言チェッカー: 例外リストの正規表現構築に失敗しました。", e);
    return null;
  }
}

/**
 * マッチした単語とルールに基づき、ハイライト用の<span>要素を作成する (v2.6ロジック)
 * (大文字小文字を区別して照合)
 * @param {string} match - マッチした単語
 * @param {object} rules - ルールオブジェクト
 */
function createHighlightSpan(match, rules) {
  
  // v2.8: 例外チェックロジックを scanAndHighlight に移動したため、
  // ここに来る match はハイライト対象確定

  const span = document.createElement('span');
  let title = '指摘あり';
  let className = ''; 
  let note = null;

  // v2.5: toLowerCase() を使わずに、そのまま(match)照合する
  // 推奨語をチェック
  if (rules.preferred_terms && Array.isArray(rules.preferred_terms)) {
    const preferred = rules.preferred_terms.find(term => term && term.old === match);
    if (preferred) {
      className = 'web-checker-highlight-preferred';
      title = `推奨: '${preferred.new || '?'}' に変更`;
      note = preferred.note;
    }
  }
  
  // 推奨語でない場合、禁止語をチェック
  if (!className && rules.forbidden_words && Array.isArray(rules.forbidden_words)) {
    const forbidden = rules.forbidden_words.find(rule => rule && rule.word === match);
    if (forbidden) {
      className = 'web-checker-highlight-forbidden';
      title = `禁止語: ${forbidden.word}`;
      note = forbidden.note;
    }
  }

  // もしどちらでもない場合 (正規表現が(A|B)でマッチしたが、ルールリストにない場合)
  // v2.5の厳格なロジックでは、ルールにないものはハイライトしない
  if (!className) {
     // v2.6の正規表現(g2)により、matchは必ずルールのどれかに一致するはず
     return document.createTextNode(match); 
  }

  // 注釈（note）があれば、titleに追加
  if (note) {
    title += ` (${note})`;
  }

  span.className = className;
  span.title = title;
  span.textContent = match;
  return span;
}

/**
 * 正規表現用の特殊文字をエスケープする
 */
function escapeRegExp(string) {
  if (typeof string !== 'string') {
    console.warn('Web文言チェッカー: ルールに文字列でない値が含まれています。', string);
    return '';
  }
  return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}



